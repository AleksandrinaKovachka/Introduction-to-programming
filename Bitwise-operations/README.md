# Програми и функции с побитови операции

В случаи когато е необходим "достъп" до отделни битове на целочислени/символни данни, в C/C++ програмите се използват т. нар. побитови операции.

Поддържат се шест оператора за извършване на операции на побитово ниво:
=

&	побитов AND (И)

|	побитов OR (ИЛИ)

^	побитов XOR (изключващо ИЛИ - неравнозначност)

~	побитов NOT (НЕ - отрицание)

<<	побитово изместване вляво (left shift)

 >>	побитово изместване вдясно (right shift)

Побитовите оператори са валидни и могат да се използват само с данни от тип char и int (целочислени). 

Подобно на логическите оператори, действието на побитовите оператори (без операторите за изместване) и резултатите от съответните операции
могат да се представят с таблици на истинност. 

В Таблица 12.1. с x и y е означен отделен бит от целочислен операнд.

x	y	x&y	x|y	x^y	~x	~y

0	0	 0	 0	 0	 1	 1

0	1	 0	 1	 1	 1	 0

1	0	 0	 1	 1	 0	 1

1	1	 1	 1	 0	 0	 0

Забележете, че операторите & (AND), | (OR)и ^ (XOR) са бинарни (двуоперандни), а операторът ~ (NOT) е унарен (еднооперанден).

Операторите побитов: AND (&), XOR (^), OR (|) генерират резултат, базиран на сравнението на всеки бит от първия операнд със съответния бит от втория операнд. 

Както виждате от Таблица 12.1., операторът побитов AND установява в 1 съответен бит в резултата, ако и двата сравнявани бита са 1. 

Операторът побитов OR установява в 1 съответен бит в резултата, ако поне един от сравняваните битове е 1. Операторът побитов XOR установява в 1 съответен бит в резултата,

ако един от сравняваните два бита е 1, но не и когато и двата са 1 или 0.

Операторът побитов NOT (~) инвертира (от 0 в 1 и от 1 в 0) стойността на всеки бит на операнд от тип цяло число или символ.

Подобно на логическите оператори, реда на изпълнение на тези побитови оператори за реализация на съответни операции е както следва: 
~ (най-висок приоритет), &, ^, | (най-нисък приоритет). 

Операторите за побитово изместване вляво (<<) и вдясно (>>) са бинарни. 

Общата форма на представяне на операциите с тези оператори е:

операнд1 << операнд2

операнд1 >> операнд2

Както вече разбрахте, операнд1 и операнд2 могат да бъдат изрази от целочислен или символен тип. 

Операнд2, задаващ броя битове за изместване, определя на колко позиции наляво или надясно трябва да се изместят съдържанията на битовете на операнд1.

```
Пример. Фрагмент от програма с операции за изместване:

int a=66;   // Двоичният код на 66 е 01000010

int b=166;  // Двоичният код на 166 е 10100110

cout<<"\n Стойността на a след изместване вляво е "<<(а<<=1);

cout<<"\n Стойността на b след изместване вдясно е "<<(b>>=1);

```

```
Резултати:

Стойността на a след изместване вляво е 132   // 132(10)=10000100(2)

Стойността на b след изместване вдясно е 83   //   83(10)=01010011(2)
```

В изразите за извеждане на резултатите (задължително са в скоби) е използван съставен оператор за присвояване (<<= и >>=). 

Виждате, че изместването вляво е еквивалентно на умножение по 2 , а изместването надясно е еквивалентно на деление на 2. 

Операторите за изместване са с по-нисък приоритет от аритметичните оператори и с по-висок приоритет спрямо операторите за сравнение и бинарните побитови оператори. 

Побитовите операции се използват основно за формиране, преобразуване и анализ на цифрови кодове, на отделни битове или групи от битове в данни от целочислен тип. 

Целите числа със знак в паметта на компютъра обикновено се представят двоично в т. нар. допълнителен код.

За знака на числото се използва най-старшия (най-левия) бит, който за отрицателните цели числа е със стойност 1, а за положителните - със стойност 0.

```
Пример 1. Използване на оператор побитов OR за превръщане на цяло положително число в отрицателно.

/* Програма за превръщане на цяло положително число в отрицателно.   

Използва се операция | (побитово OR), чрез която най-старшия бит на числото (определящ знака: 0 за положително или 1 за отрицателно число) се формира със стойност 1. 

Двоичният код на целочислената константа 32768 е 1000000000000000. */

#include <iostream.h>

#include <conio.h>


void main()

{
 int i;

 cout << "\n Въведете положително цяло число <=32767: ";
 
 cin >> i;  i = i|32768;     // Сменя знака на положително число
 
 cout << "\n Допълващото отрицателно число е " << i;
 
 getch();
 
}

```
При изпълнението на примерната програмата ще забележете, че при смяната на знака на въведеното положително число се променя и стойността на числовата част. 

Получава се отрицателно число, чиято стойност е "допълнението" до -32768 (най-малката стойност на отрицателно int число за 16 битова програмна среда) на положителното (с обратен знак).

```
Примерно изпълнение:

Въведете положително цяло число <=32767: 16384

Допълващото отрицателно число е -16384
```
